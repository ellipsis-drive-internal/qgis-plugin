# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EllipsisConnectDialog
                                 A QGIS plugin
 Connect to Ellipsis Drive
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-06-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Ellipsis Drive
        email                : floydremmerswaal@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import json
import requests
from requests import api
from requests.structures import CaseInsensitiveDict

from threading import Timer

from PyQt5.QtWidgets import QCheckBox, QDialog, QLineEdit, QMainWindow

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.PyQt.QtCore import QSettings, pyqtSignal

from PyQt5 import QtCore

from qgis.PyQt.QtWidgets import QAction, QListWidgetItem, QListWidget, QMessageBox, QWidget, QGridLayout, QLabel

try:
    import pyclip
except ImportError:
    this_dir = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(this_dir, 'pyclip-0.5.4-py3-none-any')
    sys.path.append(path)
    import pyclip

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ellipsis_drive_dialog_base.ui'))

# definitions of constants

TABSFOLDER = os.path.join(os.path.dirname(__file__), "tabs/")
URL = 'https://api.ellipsis-drive.com/v1'

DEBUG = True

# api.ellipsis-drive.com/v1/wms/mapId
# api.ellipsis-drive.com/v1/wmts/mapId
# api.ellipsis-drive.com/v1/wfs/mapId

def getMetadata(mapid, token):
    """ Returns metadata (in JSON) for a map (by mapid) by calling the Ellipsis API"""
    apiurl = F"{URL}/metadata"
    headers = {'Content-Type': 'application/json', 'Accept':'application/json'}
    data = {
        "mapId": f"{mapid}",
    }
    j1 = requests.post(apiurl, json=data, headers=headers)
    if not j1:
        log("getMetadata failed!")
        return {}
    data = json.loads(j1.text)
    jlog(data)
    return data

class ListData:
    """ Class used for objects in the QList of the EllipsisConnect plugin """
    def __init__(self, type="none", data=""):
        self.type = type
        self.data = data
    
    def setData(self, type, data):
        self.type = type
        self.data = data

    def getData(self):
        return self.data

    def getType(self):
        return self.type

# taken from https://gist.github.com/walkermatt/2871026
def debounce(wait):
    """ Decorator that will postpone a functions
        execution until after wait seconds
        have elapsed since the last time it was invoked. """
    def decorator(fn):
        def debounced(*args, **kwargs):
            def call_it():
                fn(*args, **kwargs)
            try:
                debounced.t.cancel()
            except(AttributeError):
                pass
            debounced.t = Timer(wait, call_it)
            debounced.t.start()
        return debounced
    return decorator

def log(text):
    if DEBUG:
        print(text)

def jlog(obj):
    # create a formatted string of the Python JSON object
    text = json.dumps(obj, sort_keys=True, indent=4)
    log(text)

class MyDriveLoginTab(QDialog):
    """ login tab, sends a signal with the token on succesful login """
    loginSignal = pyqtSignal(object)
    def __init__(self):
        super(MyDriveLoginTab, self).__init__()
        uic.loadUi(os.path.join(TABSFOLDER, "MyDriveLoginTab.ui"), self)
        self.pushButton_login.clicked.connect(self.loginButton)
        self.lineEdit_username.textChanged.connect(self.onUsernameChange)
        self.lineEdit_password.textChanged.connect(self.onPasswordChange)
        self.checkBox_remember.stateChanged.connect(lambda:self.onChangeRemember(self.checkBox_remember))
        
        self.settings = QSettings('Ellipsis Drive', 'Ellipsis Drive Connect')

        self.username = ""
        self.password = ""
        self.rememberMe = False
        self.loggedIn = False
    
    def onChangeRemember(self, button):
        self.rememberMe = button.isChecked()

    def confirmRemember(self):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)

        msg.setText("Remembering your login data should only be done on devices you trust.")
        msg.setWindowTitle("Are you sure?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        retval = msg.exec_()
        return retval == QMessageBox.Ok
    
    # als de gebruiker 'remember me' niet heeft ingevuld: gewoon inloggen
    # als de gebruiker 'remember me' wel invult: verifiÃ«ren
    # Zo ja: inloggen en opslaan
    # Zo nee: niet inloggen

    def loginButton(self, value):
        actual_remember = False
        # check if the user is sure that they want us to remember their login token
        if (self.rememberMe):
            confirm_remember = self.confirmRemember()
            if (not confirm_remember):
                return
            else:
                actual_remember = True

        apiurl = f"{URL}/account/login"
        log(f'Logging in: username: {self.username}, password: {self.password}')

        headers = CaseInsensitiveDict()
        headers["Content-Type"] = "application/json"
        data = '{"username": "%s", "password": "%s"}' % (self.username, self.password)

        log(data)
        resp = requests.post(apiurl, headers=headers, data=data)
        jlog(resp.json())
        data = resp.json()
        if resp:
            #print(f"Token: {data['token']}")
            self.loggedIn = True
            loginToken = data['token']
            log("logged in")
            if actual_remember:
                self.settings.setValue("token",data["token"])
                log("login token saved to settings")
            else:
                log("token NOT saved to settings")
            self.loginSignal.emit(loginToken)
            self.username = ""
            self.password = ""
            self.lineEdit_username.setText("")
            self.lineEdit_password.setText("")

        else:
            log("Login failed")

    def onUsernameChange(self, text):
        self.username = text

    def onPasswordChange(self, text):
        self.password = text

class MyDriveLoggedInTab(QDialog):
    logoutSignal = pyqtSignal()
    def __init__(self):
        super(MyDriveLoggedInTab, self).__init__()
        uic.loadUi(os.path.join(TABSFOLDER, "MyDriveLoggedInTab.ui"), self)
        self.loginToken = ""
        self.loggedIn = False
        self.pushButton_logout.clicked.connect(self.logOut)
        self.settings = QSettings('Ellipsis Drive', 'Ellipsis Drive Connect')
    
    def logOut(self):
        log("logging out")
        if (self.settings.contains("token")):
            self.settings.remove("token")
        self.logoutSignal.emit()

class MyDriveTab(QDialog):
    def __init__(self):
        super(MyDriveTab, self).__init__()
        uic.loadUi(os.path.join(TABSFOLDER, "MyDriveStack.ui"), self)

        # idea: use QStacketWidget to switch between logged in and logged out

        self.loginWidget = MyDriveLoginTab()
        self.loggedInWidget = MyDriveLoggedInTab()

        self.loggedIn = False
        self.loginToken = ""

        self.loginWidget.loginSignal.connect(self.handleLoginSignal)
        self.loggedInWidget.logoutSignal.connect(self.handleLogoutSignal)

        self.stackedWidget.addWidget(self.loginWidget)
        self.stackedWidget.addWidget(self.loggedInWidget)
        
        self.settings = QSettings('Ellipsis Drive', 'Ellipsis Drive Connect')

        if (self.settings.contains("token")):
            log("Login data found")
            self.loggedIn = True
            self.loginToken = self.settings.value("token")
            self.stackedWidget.setCurrentIndex(1)
        else:
            log("No login data found")

    def handleLoginSignal(self, token):
        log("login signal received!")
        self.loginToken = token
        self.loggedIn = True
        self.loggedInWidget.loginToken = token
        self.loggedInWidget.loggedIn = True
        self.stackedWidget.setCurrentIndex(1)
    
    def handleLogoutSignal(self):
        log("logout signal received!")
        self.loggedIn = False
        self.loginToken = ""
        self.loggedInWidget.loggedIn = False
        self.loggedInWidget.loginToken = ""
        self.stackedWidget.setCurrentIndex(0)
    
class CommunityTab(QDialog):
    def __init__(self):
        super(CommunityTab, self).__init__()
        uic.loadUi(os.path.join(TABSFOLDER, "CommunityTab.ui"), self)
        self.communitySearch = ""
        self.radioState = "raster"
        self.currentlySelectedId = ""

        self.listWidget_community.itemClicked.connect(self.onCommunityItemClick)
        self.lineEdit_communitysearch.textChanged.connect(self.onCommunitySearchChange)

        self.pushButton_wms.clicked.connect(lambda:self.getUrl("wms", self.currentlySelectedId))
        self.pushButton_wmts.clicked.connect(lambda:self.getUrl("wmts", self.currentlySelectedId))
        self.pushButton_wfs.clicked.connect(lambda:self.getUrl("wfs", self.currentlySelectedId))

        self.disableCorrectButtons(True)
        
        self.radioRaster.toggled.connect(lambda:self.manageRadioState(self.radioRaster))
        self.radioVector.toggled.connect(lambda:self.manageRadioState(self.radioVector))

        self.getCommunityList()

# api.ellipsis-drive.com/v1/wms/mapId
# api.ellipsis-drive.com/v1/wmts/mapId
# api.ellipsis-drive.com/v1/wfs/mapId

    def disableCorrectButtons(self, all = False):
        if all:
            self.pushButton_wms.setEnabled(False)
            self.pushButton_wmts.setEnabled(False)
            self.pushButton_wfs.setEnabled(False)
        elif self.radioState == "raster":
            self.pushButton_wms.setEnabled(True)
            self.pushButton_wmts.setEnabled(True)
            self.pushButton_wfs.setEnabled(False)
        else:
            self.pushButton_wms.setEnabled(False)
            self.pushButton_wmts.setEnabled(False)
            self.pushButton_wfs.setEnabled(True)
            

    def getUrl(self, mode, mapId):
        apiurl = f"{URL}/{mode}/{mapId}"
        log(f"getUrl: {apiurl}")
        pyclip.copy(apiurl)
        msg = QMessageBox()
        msg.setWindowTitle("Success")
        msg.setIcon(QMessageBox.Information)
        msg.setText("Url copied to clipboard!")
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()


    def manageRadioState(self, b):
        if b.text() == "Raster data":
            if b.isChecked():
                self.radioState = "raster"
            else:
                self.radioState = "vector"
        elif b.text() == "Vector data":
            if b.isChecked():
                self.radioState = "vector"
            else:
                self.radioState = "raster"
        if (self.currentlySelectedId != ""):
            self.disableCorrectButtons()
        else:
            self.disableCorrectButtons(True)

    @debounce(0.5)
    def getCommunityList(self):
        """ gets the list of public projects and add them to the list widget on the community tab """

        # reset the list before updating it
        self.listWidget_community.clearSelection()
        self.listWidget_community.clear()
        self.currentlySelectedId = ""
        self.disableCorrectButtons(True)

        apiurl = f"{URL}/account/maps"
        log("Getting community maps")
        headers = {'Content-Type': 'application/json', 'Accept':'application/json'}
        data = {
            "access": ["public"],
            "name": f"{self.communitySearch}"
        }

        j1 = requests.post(apiurl, json=data, headers=headers)
        if not j1:
            log("getCommunityList failed!")
            return []
        data = json.loads(j1.text)
        for mapdata in data["result"]:
            newitem = QListWidgetItem()
            newitem.setText(mapdata["name"])
            item = ListData("id", mapdata["id"])
            newitem.setData(QtCore.Qt.UserRole, item)
            self.listWidget_community.addItem(newitem)
        
    def onCommunitySearchChange(self, text):
        """ Change the internal state of the community search string """
        self.communitySearch = text
        self.getCommunityList()

    def onCommunityItemClick(self, item):
        self.disableCorrectButtons()
        self.currentlySelectedId = item.data((QtCore.Qt.UserRole)).getData()
        log(f"{item.text()}, data type: {item.data((QtCore.Qt.UserRole)).getType()}, data value: {item.data((QtCore.Qt.UserRole)).getData()}")

        
# idee: laat de Tabs wel gewoon hun eigen klasse zijn, maar de UI files laden
class EllipsisConnectDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(EllipsisConnectDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #loginTab = uic.loadUi(os.path.join(TABSFOLDER, "LoginTab.ui"))
        #communityTab = uic.loadUi(os.path.join(TABSFOLDER, "CommunityTab.ui"))

        self.setupUi(self)
        self.tabWidget.addTab(MyDriveTab(), "My Drive")
        self.tabWidget.addTab(CommunityTab(), "Community Library")